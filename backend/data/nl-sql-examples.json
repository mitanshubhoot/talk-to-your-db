{
  "metadata": {
    "version": "1.0",
    "created": "2024-10-30",
    "description": "High-quality curated NL-SQL example pairs for few-shot learning",
    "totalExamples": 28,
    "categories": [
      "basic_select",
      "filtering",
      "aggregation", 
      "joins",
      "analytics",
      "time_series",
      "ranking",
      "complex_business"
    ]
  },
  "examples": [
    {
      "id": "basic_001",
      "category": "basic_select",
      "naturalLanguage": "show me all customers",
      "sql": "SELECT customer_id, name, email, city, country FROM customers ORDER BY name LIMIT 20;",
      "explanation": "Retrieves all customer information with a reasonable limit and sorted by name for readability",
      "schemaContext": "customers table with customer_id, name, email, city, country columns",
      "queryPattern": {
        "type": "select_all",
        "complexity": "simple",
        "tables": ["customers"],
        "operations": ["SELECT", "ORDER BY", "LIMIT"],
        "keywords": ["show", "all", "customers"]
      },
      "qualityScore": 95,
      "tags": ["basic", "select", "customers", "list"],
      "businessContext": "Customer management - viewing customer directory"
    },
    {
      "id": "basic_002", 
      "category": "basic_select",
      "naturalLanguage": "list all products",
      "sql": "SELECT product_id, name, price, category, description FROM products ORDER BY name LIMIT 20;",
      "explanation": "Shows all products with key information, sorted alphabetically",
      "schemaContext": "products table with product_id, name, price, category, description columns",
      "queryPattern": {
        "type": "select_all",
        "complexity": "simple",
        "tables": ["products"],
        "operations": ["SELECT", "ORDER BY", "LIMIT"],
        "keywords": ["list", "all", "products"]
      },
      "qualityScore": 95,
      "tags": ["basic", "select", "products", "catalog"],
      "businessContext": "Product catalog management - viewing inventory"
    },
    {
      "id": "count_001",
      "category": "aggregation",
      "naturalLanguage": "how many customers do we have",
      "sql": "SELECT COUNT(*) as customer_count FROM customers;",
      "explanation": "Counts the total number of customers in the database",
      "schemaContext": "customers table",
      "queryPattern": {
        "type": "count",
        "complexity": "simple",
        "tables": ["customers"],
        "operations": ["COUNT"],
        "keywords": ["how", "many", "customers"]
      },
      "qualityScore": 98,
      "tags": ["count", "aggregate", "customers", "total"],
      "businessContext": "Business metrics - customer base size"
    },
    {
      "id": "count_002",
      "category": "aggregation", 
      "naturalLanguage": "count the number of orders",
      "sql": "SELECT COUNT(*) as order_count FROM orders;",
      "explanation": "Returns the total count of orders in the system",
      "schemaContext": "orders table",
      "queryPattern": {
        "type": "count",
        "complexity": "simple",
        "tables": ["orders"],
        "operations": ["COUNT"],
        "keywords": ["count", "number", "orders"]
      },
      "qualityScore": 98,
      "tags": ["count", "aggregate", "orders", "total"],
      "businessContext": "Sales metrics - total order volume"
    },
    {
      "id": "filter_001",
      "category": "filtering",
      "naturalLanguage": "customers from New York",
      "sql": "SELECT customer_id, name, email, city FROM customers WHERE city = 'New York' ORDER BY name;",
      "explanation": "Filters customers to show only those located in New York",
      "schemaContext": "customers table with city column",
      "queryPattern": {
        "type": "filter",
        "complexity": "simple",
        "tables": ["customers"],
        "operations": ["SELECT", "WHERE", "ORDER BY"],
        "keywords": ["customers", "from", "new york", "city"]
      },
      "qualityScore": 92,
      "tags": ["filter", "location", "customers", "city"],
      "businessContext": "Geographic analysis - regional customer base"
    },
    {
      "id": "filter_002",
      "category": "filtering",
      "naturalLanguage": "products with price greater than 100",
      "sql": "SELECT product_id, name, price, category FROM products WHERE price > 100 ORDER BY price DESC;",
      "explanation": "Shows products priced above $100, sorted by price from highest to lowest",
      "schemaContext": "products table with price column",
      "queryPattern": {
        "type": "filter",
        "complexity": "simple",
        "tables": ["products"],
        "operations": ["SELECT", "WHERE", "ORDER BY"],
        "keywords": ["products", "price", "greater", "than"]
      },
      "qualityScore": 90,
      "tags": ["filter", "price", "products", "threshold"],
      "businessContext": "Product analysis - premium product segment"
    },
    {
      "id": "filter_003",
      "category": "filtering",
      "naturalLanguage": "orders placed in the last 30 days",
      "sql": "SELECT order_id, customer_id, order_date, total_amount FROM orders WHERE order_date >= CURRENT_DATE - INTERVAL '30 days' ORDER BY order_date DESC;",
      "explanation": "Retrieves recent orders from the past month, sorted by most recent first",
      "schemaContext": "orders table with order_date column",
      "queryPattern": {
        "type": "filter",
        "complexity": "medium",
        "tables": ["orders"],
        "operations": ["SELECT", "WHERE", "ORDER BY", "INTERVAL"],
        "keywords": ["orders", "last", "30", "days", "recent"]
      },
      "qualityScore": 88,
      "tags": ["filter", "date", "orders", "recent"],
      "businessContext": "Sales analysis - recent order activity"
    },
    {
      "id": "ranking_001",
      "category": "ranking",
      "naturalLanguage": "top 5 customers by total orders",
      "sql": "SELECT c.customer_id, c.name, COUNT(o.order_id) as total_orders FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name ORDER BY total_orders DESC LIMIT 5;",
      "explanation": "Finds the 5 customers with the most orders by joining customers and orders tables",
      "schemaContext": "customers and orders tables with foreign key relationship",
      "queryPattern": {
        "type": "top_n",
        "complexity": "medium",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "LIMIT", "COUNT"],
        "keywords": ["top", "5", "customers", "total", "orders"]
      },
      "qualityScore": 88,
      "tags": ["top", "ranking", "customers", "orders", "join"],
      "businessContext": "Customer analysis - most active customers"
    },
    {
      "id": "ranking_002",
      "category": "ranking",
      "naturalLanguage": "top 10 products by revenue",
      "sql": "SELECT p.product_id, p.name, SUM(oi.quantity * oi.price) as total_revenue FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "explanation": "Calculates revenue for each product and shows the top 10 by total sales",
      "schemaContext": "products and order_items tables with foreign key relationship",
      "queryPattern": {
        "type": "top_n",
        "complexity": "medium",
        "tables": ["products", "order_items"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "LIMIT", "SUM"],
        "keywords": ["top", "10", "products", "revenue", "sales"]
      },
      "qualityScore": 85,
      "tags": ["top", "ranking", "products", "revenue", "join"],
      "businessContext": "Product analysis - best performing products by revenue"
    },
    {
      "id": "ranking_003",
      "category": "ranking",
      "naturalLanguage": "bottom 5 products by sales volume",
      "sql": "SELECT p.product_id, p.name, COALESCE(SUM(oi.quantity), 0) as total_quantity FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name ORDER BY total_quantity ASC LIMIT 5;",
      "explanation": "Identifies the 5 products with lowest sales volume, including products with no sales",
      "schemaContext": "products and order_items tables with foreign key relationship",
      "queryPattern": {
        "type": "top_n",
        "complexity": "medium",
        "tables": ["products", "order_items"],
        "operations": ["SELECT", "LEFT JOIN", "GROUP BY", "ORDER BY", "LIMIT", "SUM", "COALESCE"],
        "keywords": ["bottom", "5", "products", "sales", "volume"]
      },
      "qualityScore": 87,
      "tags": ["bottom", "ranking", "products", "sales", "left-join"],
      "businessContext": "Product analysis - underperforming products"
    },
    {
      "id": "aggregate_001",
      "category": "aggregation",
      "naturalLanguage": "total revenue by month",
      "sql": "SELECT DATE_TRUNC('month', order_date) as month, SUM(total_amount) as monthly_revenue FROM orders GROUP BY DATE_TRUNC('month', order_date) ORDER BY month DESC;",
      "explanation": "Groups orders by month and calculates total revenue for each month",
      "schemaContext": "orders table with order_date and total_amount columns",
      "queryPattern": {
        "type": "aggregate",
        "complexity": "medium",
        "tables": ["orders"],
        "operations": ["SELECT", "GROUP BY", "ORDER BY", "SUM", "DATE_TRUNC"],
        "keywords": ["total", "revenue", "by", "month"]
      },
      "qualityScore": 87,
      "tags": ["aggregate", "revenue", "monthly", "time-series"],
      "businessContext": "Financial analysis - monthly revenue trends"
    },
    {
      "id": "aggregate_002",
      "category": "aggregation",
      "naturalLanguage": "average order value by customer",
      "sql": "SELECT c.customer_id, c.name, AVG(o.total_amount) as avg_order_value, COUNT(o.order_id) as order_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name ORDER BY avg_order_value DESC;",
      "explanation": "Calculates the average order value for each customer along with their order count",
      "schemaContext": "customers and orders tables with foreign key relationship",
      "queryPattern": {
        "type": "aggregate",
        "complexity": "medium",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "AVG", "COUNT"],
        "keywords": ["average", "order", "value", "by", "customer"]
      },
      "qualityScore": 86,
      "tags": ["aggregate", "average", "customers", "orders", "join"],
      "businessContext": "Customer analysis - customer value segmentation"
    },
    {
      "id": "aggregate_003",
      "category": "aggregation",
      "naturalLanguage": "sales summary by category",
      "sql": "SELECT p.category, COUNT(DISTINCT p.product_id) as product_count, SUM(oi.quantity) as total_quantity, SUM(oi.quantity * oi.price) as total_revenue FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.category ORDER BY total_revenue DESC;",
      "explanation": "Provides comprehensive sales metrics grouped by product category",
      "schemaContext": "products and order_items tables with category and sales data",
      "queryPattern": {
        "type": "aggregate",
        "complexity": "medium",
        "tables": ["products", "order_items"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "COUNT", "SUM"],
        "keywords": ["sales", "summary", "by", "category"]
      },
      "qualityScore": 89,
      "tags": ["aggregate", "category", "sales", "summary"],
      "businessContext": "Product analysis - category performance overview"
    },
    {
      "id": "join_001",
      "category": "joins",
      "naturalLanguage": "orders with customer information",
      "sql": "SELECT o.order_id, o.order_date, o.total_amount, c.name as customer_name, c.email as customer_email FROM orders o JOIN customers c ON o.customer_id = c.customer_id ORDER BY o.order_date DESC LIMIT 20;",
      "explanation": "Combines order data with customer details to show comprehensive order information",
      "schemaContext": "orders and customers tables with foreign key relationship",
      "queryPattern": {
        "type": "join",
        "complexity": "medium",
        "tables": ["orders", "customers"],
        "operations": ["SELECT", "JOIN", "ORDER BY", "LIMIT"],
        "keywords": ["orders", "with", "customer", "information"]
      },
      "qualityScore": 90,
      "tags": ["join", "orders", "customers", "details"],
      "businessContext": "Order management - order details with customer context"
    },
    {
      "id": "join_002",
      "category": "joins",
      "naturalLanguage": "products and their order details",
      "sql": "SELECT p.product_id, p.name as product_name, p.category, oi.quantity, oi.price, o.order_date FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id ORDER BY o.order_date DESC LIMIT 25;",
      "explanation": "Shows product sales history by joining products, order items, and orders",
      "schemaContext": "products, order_items, and orders tables with relationships",
      "queryPattern": {
        "type": "join",
        "complexity": "medium",
        "tables": ["products", "order_items", "orders"],
        "operations": ["SELECT", "JOIN", "ORDER BY", "LIMIT"],
        "keywords": ["products", "order", "details", "sales"]
      },
      "qualityScore": 88,
      "tags": ["join", "products", "orders", "sales-history"],
      "businessContext": "Product analysis - sales transaction history"
    },
    {
      "id": "time_001",
      "category": "time_series",
      "naturalLanguage": "daily sales for the last week",
      "sql": "SELECT DATE(order_date) as sale_date, COUNT(*) as order_count, SUM(total_amount) as daily_revenue FROM orders WHERE order_date >= CURRENT_DATE - INTERVAL '7 days' GROUP BY DATE(order_date) ORDER BY sale_date;",
      "explanation": "Shows daily sales metrics for the past week with order count and revenue",
      "schemaContext": "orders table with order_date and total_amount columns",
      "queryPattern": {
        "type": "aggregate",
        "complexity": "medium",
        "tables": ["orders"],
        "operations": ["SELECT", "WHERE", "GROUP BY", "ORDER BY", "COUNT", "SUM", "DATE"],
        "keywords": ["daily", "sales", "last", "week"]
      },
      "qualityScore": 91,
      "tags": ["time-series", "daily", "sales", "recent"],
      "businessContext": "Sales analysis - short-term performance tracking"
    },
    {
      "id": "time_002",
      "category": "time_series",
      "naturalLanguage": "quarterly revenue comparison",
      "sql": "SELECT EXTRACT(year FROM order_date) as year, EXTRACT(quarter FROM order_date) as quarter, SUM(total_amount) as quarterly_revenue FROM orders GROUP BY EXTRACT(year FROM order_date), EXTRACT(quarter FROM order_date) ORDER BY year DESC, quarter DESC;",
      "explanation": "Compares revenue across quarters and years for trend analysis",
      "schemaContext": "orders table with order_date and total_amount columns",
      "queryPattern": {
        "type": "aggregate",
        "complexity": "medium",
        "tables": ["orders"],
        "operations": ["SELECT", "GROUP BY", "ORDER BY", "SUM", "EXTRACT"],
        "keywords": ["quarterly", "revenue", "comparison"]
      },
      "qualityScore": 86,
      "tags": ["time-series", "quarterly", "revenue", "comparison"],
      "businessContext": "Financial analysis - quarterly performance trends"
    },
    {
      "id": "analytics_001",
      "category": "analytics",
      "naturalLanguage": "customers who haven't placed orders in the last 6 months",
      "sql": "SELECT c.customer_id, c.name, c.email, MAX(o.order_date) as last_order_date FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name, c.email HAVING MAX(o.order_date) < CURRENT_DATE - INTERVAL '6 months' OR MAX(o.order_date) IS NULL ORDER BY last_order_date DESC NULLS LAST;",
      "explanation": "Identifies inactive customers using LEFT JOIN and date filtering to find those without recent orders",
      "schemaContext": "customers and orders tables with foreign key relationship",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "LEFT JOIN", "GROUP BY", "HAVING", "ORDER BY", "MAX"],
        "keywords": ["customers", "haven't", "placed", "orders", "last", "6", "months"]
      },
      "qualityScore": 82,
      "tags": ["analytics", "inactive", "customers", "complex", "left-join"],
      "businessContext": "Customer retention - identifying at-risk customers"
    },
    {
      "id": "analytics_002",
      "category": "analytics",
      "naturalLanguage": "customer lifetime value analysis",
      "sql": "SELECT c.customer_id, c.name, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as lifetime_value, AVG(o.total_amount) as avg_order_value, MIN(o.order_date) as first_order, MAX(o.order_date) as last_order FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name ORDER BY lifetime_value DESC;",
      "explanation": "Comprehensive customer value analysis including order frequency, total spend, and customer tenure",
      "schemaContext": "customers and orders tables with relationship for value calculation",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "COUNT", "SUM", "AVG", "MIN", "MAX"],
        "keywords": ["customer", "lifetime", "value", "analysis"]
      },
      "qualityScore": 93,
      "tags": ["analytics", "customer-value", "lifetime", "comprehensive"],
      "businessContext": "Customer analysis - comprehensive value assessment"
    },
    {
      "id": "analytics_003",
      "category": "analytics",
      "naturalLanguage": "monthly customer acquisition rate",
      "sql": "SELECT DATE_TRUNC('month', first_order_date) as month, COUNT(*) as new_customers FROM (SELECT customer_id, MIN(order_date) as first_order_date FROM orders GROUP BY customer_id) first_orders GROUP BY DATE_TRUNC('month', first_order_date) ORDER BY month DESC;",
      "explanation": "Tracks new customer acquisition by identifying first order dates and grouping by month",
      "schemaContext": "orders table with customer_id and order_date for acquisition tracking",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["orders"],
        "operations": ["SELECT", "GROUP BY", "ORDER BY", "COUNT", "MIN", "DATE_TRUNC", "subquery"],
        "keywords": ["monthly", "customer", "acquisition", "rate"]
      },
      "qualityScore": 89,
      "tags": ["analytics", "acquisition", "monthly", "subquery"],
      "businessContext": "Growth analysis - customer acquisition trends"
    },
    {
      "id": "complex_001",
      "category": "complex_business",
      "naturalLanguage": "product performance with inventory turnover",
      "sql": "SELECT p.product_id, p.name, p.category, COALESCE(SUM(oi.quantity), 0) as units_sold, COALESCE(SUM(oi.quantity * oi.price), 0) as revenue, CASE WHEN p.stock_quantity > 0 THEN COALESCE(SUM(oi.quantity), 0) / p.stock_quantity ELSE 0 END as turnover_ratio FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id, p.name, p.category, p.stock_quantity ORDER BY turnover_ratio DESC;",
      "explanation": "Analyzes product performance including sales volume, revenue, and inventory turnover ratios",
      "schemaContext": "products table with stock_quantity and order_items for sales data",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["products", "order_items"],
        "operations": ["SELECT", "LEFT JOIN", "GROUP BY", "ORDER BY", "SUM", "CASE", "COALESCE"],
        "keywords": ["product", "performance", "inventory", "turnover"]
      },
      "qualityScore": 91,
      "tags": ["complex", "inventory", "performance", "turnover"],
      "businessContext": "Inventory management - product performance and turnover analysis"
    },
    {
      "id": "complex_002",
      "category": "complex_business",
      "naturalLanguage": "customer segmentation by purchase behavior",
      "sql": "SELECT customer_segment, COUNT(*) as customer_count, AVG(total_orders) as avg_orders, AVG(lifetime_value) as avg_lifetime_value FROM (SELECT c.customer_id, c.name, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as lifetime_value, CASE WHEN COUNT(o.order_id) >= 10 AND SUM(o.total_amount) >= 1000 THEN 'VIP' WHEN COUNT(o.order_id) >= 5 OR SUM(o.total_amount) >= 500 THEN 'Regular' WHEN COUNT(o.order_id) >= 1 THEN 'Occasional' ELSE 'Inactive' END as customer_segment FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name) customer_stats GROUP BY customer_segment ORDER BY avg_lifetime_value DESC;",
      "explanation": "Segments customers based on purchase frequency and value, providing insights into customer tiers",
      "schemaContext": "customers and orders tables for behavioral segmentation analysis",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "LEFT JOIN", "GROUP BY", "ORDER BY", "COUNT", "SUM", "AVG", "CASE", "subquery"],
        "keywords": ["customer", "segmentation", "purchase", "behavior"]
      },
      "qualityScore": 94,
      "tags": ["complex", "segmentation", "behavior", "subquery"],
      "businessContext": "Customer analysis - behavioral segmentation for targeted marketing"
    },
    {
      "id": "complex_003",
      "category": "complex_business",
      "naturalLanguage": "seasonal sales trends with year-over-year comparison",
      "sql": "SELECT month_name, current_year_sales, previous_year_sales, ROUND(((current_year_sales - previous_year_sales) / NULLIF(previous_year_sales, 0)) * 100, 2) as growth_percentage FROM (SELECT TO_CHAR(order_date, 'Month') as month_name, EXTRACT(month FROM order_date) as month_num, SUM(CASE WHEN EXTRACT(year FROM order_date) = EXTRACT(year FROM CURRENT_DATE) THEN total_amount ELSE 0 END) as current_year_sales, SUM(CASE WHEN EXTRACT(year FROM order_date) = EXTRACT(year FROM CURRENT_DATE) - 1 THEN total_amount ELSE 0 END) as previous_year_sales FROM orders WHERE order_date >= DATE_TRUNC('year', CURRENT_DATE) - INTERVAL '1 year' GROUP BY TO_CHAR(order_date, 'Month'), EXTRACT(month FROM order_date)) monthly_comparison ORDER BY month_num;",
      "explanation": "Compares current year monthly sales with previous year, calculating growth percentages for seasonal analysis",
      "schemaContext": "orders table with order_date and total_amount for year-over-year comparison",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["orders"],
        "operations": ["SELECT", "WHERE", "GROUP BY", "ORDER BY", "SUM", "CASE", "EXTRACT", "TO_CHAR", "ROUND", "NULLIF"],
        "keywords": ["seasonal", "sales", "trends", "year-over-year", "comparison"]
      },
      "qualityScore": 88,
      "tags": ["complex", "seasonal", "year-over-year", "trends"],
      "businessContext": "Sales analysis - seasonal performance and growth tracking"
    },
    {
      "id": "window_001",
      "category": "analytics",
      "naturalLanguage": "running total of monthly revenue",
      "sql": "SELECT month, monthly_revenue, SUM(monthly_revenue) OVER (ORDER BY month) as running_total FROM (SELECT DATE_TRUNC('month', order_date) as month, SUM(total_amount) as monthly_revenue FROM orders GROUP BY DATE_TRUNC('month', order_date)) monthly_sales ORDER BY month;",
      "explanation": "Calculates cumulative revenue over time using window functions for trend analysis",
      "schemaContext": "orders table with order_date and total_amount for cumulative calculations",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["orders"],
        "operations": ["SELECT", "GROUP BY", "ORDER BY", "SUM", "OVER", "DATE_TRUNC", "window_function"],
        "keywords": ["running", "total", "monthly", "revenue"]
      },
      "qualityScore": 90,
      "tags": ["analytics", "window-function", "running-total", "cumulative"],
      "businessContext": "Financial analysis - cumulative revenue tracking"
    },
    {
      "id": "window_002",
      "category": "analytics",
      "naturalLanguage": "customer ranking by revenue with percentiles",
      "sql": "SELECT customer_id, name, total_revenue, RANK() OVER (ORDER BY total_revenue DESC) as revenue_rank, NTILE(4) OVER (ORDER BY total_revenue DESC) as revenue_quartile, PERCENT_RANK() OVER (ORDER BY total_revenue DESC) as percentile_rank FROM (SELECT c.customer_id, c.name, SUM(o.total_amount) as total_revenue FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.name) customer_revenue ORDER BY total_revenue DESC;",
      "explanation": "Ranks customers by revenue with quartile and percentile analysis using window functions",
      "schemaContext": "customers and orders tables for revenue-based ranking analysis",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["customers", "orders"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "SUM", "RANK", "NTILE", "PERCENT_RANK", "OVER"],
        "keywords": ["customer", "ranking", "revenue", "percentiles"]
      },
      "qualityScore": 92,
      "tags": ["analytics", "window-function", "ranking", "percentiles"],
      "businessContext": "Customer analysis - revenue-based customer ranking and segmentation"
    },
    {
      "id": "cohort_001",
      "category": "analytics",
      "naturalLanguage": "customer retention by cohort month",
      "sql": "SELECT cohort_month, period_number, COUNT(DISTINCT customer_id) as customers, ROUND(COUNT(DISTINCT customer_id) * 100.0 / FIRST_VALUE(COUNT(DISTINCT customer_id)) OVER (PARTITION BY cohort_month ORDER BY period_number), 2) as retention_rate FROM (SELECT c.customer_id, DATE_TRUNC('month', c.first_order_date) as cohort_month, DATE_TRUNC('month', o.order_date) as order_month, EXTRACT(month FROM AGE(o.order_date, c.first_order_date)) as period_number FROM (SELECT customer_id, MIN(order_date) as first_order_date FROM orders GROUP BY customer_id) c JOIN orders o ON c.customer_id = o.customer_id) cohort_data GROUP BY cohort_month, period_number ORDER BY cohort_month, period_number;",
      "explanation": "Analyzes customer retention rates by cohort using first order month as the cohort identifier",
      "schemaContext": "orders table for cohort analysis based on customer first order dates",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["orders"],
        "operations": ["SELECT", "JOIN", "GROUP BY", "ORDER BY", "COUNT", "MIN", "DATE_TRUNC", "EXTRACT", "AGE", "FIRST_VALUE", "OVER", "PARTITION BY"],
        "keywords": ["customer", "retention", "cohort", "month"]
      },
      "qualityScore": 95,
      "tags": ["analytics", "cohort", "retention", "advanced"],
      "businessContext": "Customer retention - cohort-based retention analysis for lifecycle insights"
    },
    {
      "id": "business_001",
      "category": "complex_business",
      "naturalLanguage": "top performing sales representatives by region",
      "sql": "SELECT sr.region, sr.rep_name, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as total_sales, AVG(o.total_amount) as avg_order_size, RANK() OVER (PARTITION BY sr.region ORDER BY SUM(o.total_amount) DESC) as region_rank FROM sales_reps sr JOIN customers c ON sr.rep_id = c.assigned_rep_id JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_date >= DATE_TRUNC('year', CURRENT_DATE) GROUP BY sr.region, sr.rep_name, sr.rep_id ORDER BY sr.region, total_sales DESC;",
      "explanation": "Analyzes sales representative performance by region with ranking and key metrics",
      "schemaContext": "sales_reps, customers, and orders tables with representative assignments",
      "queryPattern": {
        "type": "analytics",
        "complexity": "complex",
        "tables": ["sales_reps", "customers", "orders"],
        "operations": ["SELECT", "JOIN", "WHERE", "GROUP BY", "ORDER BY", "COUNT", "SUM", "AVG", "RANK", "OVER", "PARTITION BY"],
        "keywords": ["top", "performing", "sales", "representatives", "region"]
      },
      "qualityScore": 89,
      "tags": ["complex", "sales-reps", "performance", "regional"],
      "businessContext": "Sales management - representative performance analysis by geographic region"
    }
  ]
}